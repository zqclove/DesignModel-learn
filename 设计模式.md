# 设计模式

# 设计模式的六大原则

## **1、开闭原则（Open Close Principle）**

开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，**是为了使程序的扩展性好，易于维护和升级。**想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

## **2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP  是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

## **3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。（依赖降级）

## **4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

## **5、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

## **6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

**笔记：**

在面向对象设计模式中存在的是五大原则和一个法则。

**五大原则:**

- 单一职责 SRP(Single Responsibilities Principle)
- 开闭原则 OCP(Open Close Principle)
- 里氏代换 LSP(Liskov Substitution Principle)
- 倒转依赖 DIP(Dependence Inversion Principle)
- 接口隔离 ISP(Interface Segregation Principle)

一个法则是：迪米特 DP (Demeter Principle)

​	迪米特法则是管理中涉及的一个术语，被引用到面向对象术语体系中，又称知识最少原则。Least Knowledge  Principle正儿八经的翻译是就是知识最少原则，不知道哪个英文水平不济的把knowledge翻译成了知道，汉语中知道是动词没有名词的意思，而knowledge译成见闻也比相对好一点。虽然现在都知道“知道”的意思。另外，在一些台系的书中迪米特法则也被翻译成“德默特尔法则”，当你看到这个时不要奇怪——音译本就会出现多个译法的。

​	其实在清华出版社中软件设计师书中，迪米特虽然被称为法则，但其与其他五大原则是同样的重要的，所以有些人会混称为面向对象六大原则，事实上在软件设计师考试中经常使用的面向对象五大原则。按清华出版社软件设计师体系来说，面向对象五大原则和一个法则（迪法特法则）。其他时候程序员也称为六大原则。

​	在MSDN类库设计原则中提到“尽量少使用继承，而使用组合与聚合“，但其并没有说明原因。微软的惯例就是如此，只告诉你应该如何，不应该如何，尽量如何或尽量不如何，从来不会告诉你原则。在面向对象设计中（清华出版社软件设计师一书中）讲到**五大原则与法则共同的目标就是高内聚低耦合的代码。**

​	其中高内聚指的是类内成员之间的关系，而低耦合则是类关系。要求就是类内各成员的关系尽量高，并按照一定的方式对内聚性进行排序。而讲到耦合关系，按照一定的方式也进行了排序；也就是内聚度与耦合度对这种关系进行了一定程度上量化。所以此处提到了继承——继承是耦合度最高的一种关系。所以提示了一句话是**尽量使用组合或聚合的方式来代替继承，或者使用最简单的继承树关系，当然也提示了继承应该继承于抽象类，避免继承实现类。**这个是对高内聚低耦合的一个补充说明，而且没有绝对的定义。所以并不是几大原则之中的事。而且有前提前条件，只是避免继承普通类！所以合成复用原则完全是某个人背完了原则忘记了而瞎编出来的（只是会背不会用或不理解，当然容易忘记了）！

​	当然，**单一职责原则其实就是为了提高内聚性一个说明，它的目的就保证了内聚性，只有一个引起变化的原因，说明类内成员之间的关系较高，内聚性不强的就不要写到一个类中。**这就是单一职责的真正用意。事实上很多程序员爱写大类超多成员或爱用静态成员，都是对内聚性的一种破坏——所以这些人很难想起来还有一个单一职责的原则！慢慢的这个原则就是被忘记了！

***以上来自 tech_monkey的笔记***



# 创建型

这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

创建型的模式有一下几种：

- 工厂模式（Factory Pattern）
- 抽象工厂模式（Abstract Factory Pattern）
- 单例模式（Singleton Pattern）
- 建造者模式（Builder Pattern）
- 原型模式（Prototype Pattern）

## 单例模式

单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一对象的方式。该对象可以被直接访问，其他调用方不需要实例化该类的对象。

**注意：**

- 1、单例类只能有一个实例。
- 2、单例类必须自己创建自己的唯一实例。
- 3、单例类必须给所有其他对象提供这一实例。

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。

**应用实例：**

1、一个班级只有一个班主任。

2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。

3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

**优点：**

1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。

2、避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**使用场景：**

1、要求生产唯一序列号。 

2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。

3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

**注意事项：**getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

### 实现

单例模式的实现有多种：

#### 懒汉式-线程不安全

实现思路：延迟初始化思想，在不适用该类的情况下，不去实例化该类。只有当使用该类时，才去实例化该单例类。

这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 `if (uniqueInstance == null)` ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 `uniqueInstance = new Singleton();` 语句，这将导致实例化多次 uniqueInstance。

```java
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
```

#### 饿汉式-线程安全

线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。

但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。

```java
private static Singleton uniqueInstance = new Singleton();
```

#### 懒汉式-线程安全

使用synchronized关键字修饰获取单例的方法，确保只有一个线程能够进入该方法，从而避免多次实例化 uniqueInstance 的情况。

但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化后不需要同步的情况也会加锁。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。

```java
public static synchronized Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}
```

#### 双重校验锁-线程安全

因为 uniqueInstance 为空的情况只会出现一次，因此加锁操作可以细化到只有 uniqueInstance 没有被实例化时才需要进行加锁。

双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 `uniqueInstance = new Singleton();` 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免  uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现  uniqueInstance == null 时两个线程同时进行实例化操作。

```java
if (uniqueInstance == null) {
    synchronized (Singleton.class) {
        uniqueInstance = new Singleton();
    }
}
```

uniqueInstance 采用 volatile 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：

1. 为 uniqueInstance 分配内存空间
2. 初始化 uniqueInstance
3. 将 uniqueInstance 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1>3>2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。

使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。

#### 静态内部类实现

当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 `getUniqueInstance()` 方法从而触发 `SingletonHolder.INSTANCE` 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。

这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。

```java
public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

#### 枚举实现

```java
public enum Singleton {

    INSTANCE;

    private String objName;


    public String getObjName() {
        return objName;
    }


    public void setObjName(String objName) {
        this.objName = objName;
    }


    public static void main(String[] args) {

        // 单例测试
        Singleton firstSingleton = Singleton.INSTANCE;
        firstSingleton.setObjName("firstName");
        System.out.println(firstSingleton.getObjName());
        Singleton secondSingleton = Singleton.INSTANCE;
        secondSingleton.setObjName("secondName");
        System.out.println(firstSingleton.getObjName());
        System.out.println(secondSingleton.getObjName());

        // 反射获取实例测试
        try {
            Singleton[] enumConstants = Singleton.class.getEnumConstants();
            for (Singleton enumConstant : enumConstants) {
                System.out.println(enumConstant.getObjName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
firstName
secondName
secondName
secondName
```

该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为  public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM  保证只会实例化一次，因此不会出现上述的反射攻击。

该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。

这种方式是 Effective Java 作者 Josh Bloch  提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5  之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。
这种方式能通过 reflection attack 来调用私有构造方法。

## 工厂模式

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决：**主要解决接口选择的问题。

**何时使用：**我们明确地计划不同条件下创建不同实例时。

**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。

**关键代码：**创建过程在其子类执行。

**应用实例：** 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。

**优点：** 1、一个调用者想创建一个对象，只要知道其名称就可以了。  2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**使用场景：** 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

### 实现

使用shape的例子，在下面不列出该shape体系类，只给出工厂类。

**工厂模式（工厂方法）:** 定义一个创建对象的接口（ShapeFactory），但由其子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。该模式在扩展产品（新的shape子类）时，需要配套一个创建该产品的工厂。

```java
public abstract class ShapeFactory {
	abstract public Shape getObject();
}

public class CircleFactory extends Factory{
    public Shape getObject() {
        return new Circle();
    }
}

public class RectangleFactory extends Factory{
    public Shape getObject() {
        return new Rectangle();
    }
}

public class SquareFactory extends Factory{
    public Shape getObject() {
        return new Square();
    }
}

public static void main() {
    ShapeFactory sf = new CircleFactory();
    Shape shape = sf.getObject(); // 获取到Circle对象。
}
```

**枚举优化工厂模式：**对工厂模式的一种优化，防止传入参数时，把circle拼写错误。

```java
public enum ShapeFactory {
    CIRCLE("CIRCLE", new Circle()),
    RECTANGLE("RECTANGLE", new Rectangle()),
    SQUARE("SQUARE", new Square());
    
    private String name;
    private Shape shape;
    
    // 这是简单工厂的变形
    public static Shape getObject(String name) {
        for (ShapeFactory sf : ShapeFactory.values()) {
            if (sf.name.equals(name)) {
                return sf.shape;
            }
        }
        return null;
    }
    
    private ShapeFactory(String name, Shape shape){
        this.name = name;
        this.shape = shape;
    }
    
    // getter and setter
    
    public static void main(String[] args) {
        Shape shape = ShapeFactory.getObject("CIRCLE"); // 获取Circle对象（可能拼写错误）
        
        ShapeFactory rectangle = ShapeFactory.RECTANGLE; // 获取存有Rectangle对象的工厂
        Shape shape2 = rectangle.shape; // 获取Rectangle对象
    }
}
```

### 注意

1. 简单工厂是否是设计模式还比较模糊，有些书籍将它视为设计模式，有些则不。
2. 对于工厂模式的另一种优化，使用反射机制创建对象。这种方式违反了迪米特法则，反射需要知道类名，而知道类名还不如直接创建，使用工厂创建将会多此一举。

## 抽象工厂

​	抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

**意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**主要解决：**主要解决接口选择的问题。

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**如何解决：**在一个产品族里面，定义多个产品。

**关键代码：**在一个工厂里聚合多个同类产品。

**应用实例：**工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP  的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**使用场景：** 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。

**注意事项：**产品族难扩展，产品等级易扩展。

### 实现

以 Shape 、 Color 接口 和其实现类作为例子。在这里不例如出接口和实现。

```java
public abstract class AbstractFactory {
    abstract Shape getShape();
    abstract Color getColor();
}

// shape工厂可以参照上面工厂模式的实现，这里只贴出ColorFactory
public abstract class ColorFactory extends AbstractFactory{
    
}

class RedFactory extends ColorFactory {

    @Override
    Shape getShape() {
        return null;
    }

    @Override
    Color getColor() {
        return new Red();
    }
    
}

class BlueFactory extends ColorFactory {

    @Override
    Shape getShape() {
        return null;
    }

    @Override
    Color getColor() {
        return new Blue();
    }
    
}

class GreenFactory extends ColorFactory {

    @Override
    Shape getShape() {
        return null;
    }

    @Override
    Color getColor() {
        return new Green();
    }
    
}

public class test{
    public static void main(String[] args) {
        AbstractFactory ab = new RedFactory(); // 获取工厂
        Color color = ab.getColor();  // 获取对象
    }
    
    // 也可以使用简单工厂的方式，根据名称指定工厂，也可根据名称指定对象。
}
```

### 区别

- **简单工厂**：
- **工厂模式**：
- **抽象工厂**：

## 建造者模式

​	建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

**主要解决：**主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

**何时使用：**一些基本部件不会变，而其组合经常变化的时候。

**如何解决：**将变与不变分离开。

**关键代码：**建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。

**应用实例：** 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。

**优点：** 1、建造者独立，易扩展。 2、便于控制细节风险。

**缺点：** 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

**使用场景：** 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。

**注意事项：**与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

### 实现

JDK中 **StringBuilder** 就是建造者模式的例子。

下面使用菜鸟教程中的快餐店案例解释建造者模式，给出类图：

![建造者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/builder_pattern_uml_diagram.jpg)

- **Item接口：**表示食物菜单
- **Packing接口**：表示包装方式（这里冷饮用瓶子，汉堡用纸盒）
- **Wrapper/Bottle：**Packing的实现类
- **Burger/ColdDrink：**实现Item的抽象类，只提供默认功能（这里是包装方式）
- **VegBurger/ChikenBurger：**实体类，Burger的子类
- **Pepsi/Coke：**实体类，ColdDrink的子类
- **Meal：**套餐，带有Item对象的List，表示已选择的食物（组件）
- **MealBuilder：**负责创建Meal，对外提供的接口。

```java
// 定义接口类
public interface Item {
    public String name();
    public Packing packing();
    public float price();
}

public interface Packing {
    public String pack();
}

// 定义Packing的实体类
public class Wrapper implements Packing {
 
   @Override
   public String pack() {
      return "Wrapper";
   }
}

public class Bottle implements Packing {
 
   @Override
   public String pack() {
      return "Bottle";
   }
}

// 定义实现Item的抽象类
public abstract class Burger implements Item {
 
   @Override
   public Packing packing() {
      return new Wrapper();
   }
 
   @Override
   public abstract float price();
}

public abstract class ColdDrink implements Item {
 
    @Override
    public Packing packing() {
       return new Bottle();
    }
 
    @Override
    public abstract float price();
}

// 定义Item实体类（继承了上面的抽象类）
public class VegBurger extends Burger {
 
   @Override
   public float price() {
      return 25.0f;
   }
 
   @Override
   public String name() {
      return "Veg Burger";
   }
}

public class ChickenBurger extends Burger {
 
   @Override
   public float price() {
      return 50.5f;
   }
 
   @Override
   public String name() {
      return "Chicken Burger";
   }
}

public class Coke extends ColdDrink {
 
   @Override
   public float price() {
      return 30.0f;
   }
 
   @Override
   public String name() {
      return "Coke";
   }
}

public class Pepsi extends ColdDrink {
 
   @Override
   public float price() {
      return 35.0f;
   }
 
   @Override
   public String name() {
      return "Pepsi";
   }
}

// Meal类，建造器的建造对象
public class Meal {
   private List<Item> items = new ArrayList<Item>();    
 
   public void addItem(Item item){
      items.add(item);
   }
 
   public float getCost(){
      float cost = 0.0f;
      for (Item item : items) {
         cost += item.price();
      }        
      return cost;
   }
 
   public void showItems(){
      for (Item item : items) {
         System.out.print("Item : "+item.name());
         System.out.print(", Packing : "+item.packing().pack());
         System.out.println(", Price : "+item.price());
      }        
   }    
}

// 建造器：建造的方式可以不用写死，参考简单工厂和枚举
public class MealBuilder {
    public Meal prepareVegMeal() {
        Meal meal = new Meal();
        meal.addItem(new VegBurger()); // 因为方法名固定是VegBurger
        meal.addItem(new Coke()); // 也可以是pepsi
        return meal;
    }

    public Meal prepareNonVegMeal() {
        Meal meal = new Meal();
        meal.addItem(new ChickenBurger());
        meal.addItem(new Pepsi());
        return meal;
    }
}

// demo
public class BuilderPatternDemo {
    public static void main(String[] args) {
        MealBuilder mealBuilder = new MealBuilder();
        
        Meal vegMeal = mealBuilder.prepareVegMeal();
        System.out.println("Veg Meal");
        vegMeal.showItems();
        System.out.println("Total Cost: " + vegMeal.getCost());

        Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
        System.out.println("\n\nNon-Veg Meal");
        nonVegMeal.showItems();
        System.out.println("Total Cost: " + nonVegMeal.getCost());
    }
}
```

### 理解

​	建造者模式主要目的是使用多个简单的对象建造一个复杂对象，所以**建造**是重点，而如何定义简单对象可以是各种方式，例如组合、关联、继承等，而使用何种方式去建造也可根据需求定义扩展性较高的方式，例如类似简单工厂的方式、枚举的方式。从相反的角度看建造者模式也可以理解为将一个复杂对象拆分成多个简单对象，并使用建造器按需要将简单对象组装成复杂对象（类似自助餐、积木的概念）。

## 原型模式

​	原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**主要解决：**在运行期建立和删除原型。

**何时使用：** 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

**如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。

**关键代码：** 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。

**应用实例：** 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。

**优点：** 1、性能提高。 2、逃避构造函数的约束。

**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。

**使用场景：** 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。

**注意事项：**与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。

### 实现

```java
public abstract class Prototype {
    abstract Prototype myClone();
}
public class ConcretePrototype extends Prototype {

    private String filed;

    public ConcretePrototype(String filed) {
        this.filed = filed;
    }

    @Override
    Prototype myClone() {
        /* 这里不适用clone方法而使用构造器的复制方式，
         * 是因为clone方法拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换
         * effective java讲到，最好不要使用clone方法，
         * 可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。
         */
        return new ConcretePrototype(filed);
    }

    @Override
    public String toString() {
        return filed;
    }
}
public class Client {
    public static void main(String[] args) {
        Prototype prototype = new ConcretePrototype("abc");
        Prototype clone = prototype.myClone();
        System.out.println(clone.toString());
    }
}
```

**问题**：原型模型是为了逃避构造函数的约束而使用的，这里使用构造函数替换clone方法是正确的吗？

**思考方向**：new一个对象和clone一个对象的区别。

### 理解

​	原型模式是实现了一个原型接口，该接口用于创建当前对象的克隆。重点在于克隆，原型模式可以使用各种方式去创建该对象的克隆，无论是浅拷贝、深拷贝，主要目的是对资源和性能的优化，例如创建一个对象时需要调用数据库或其他繁重操作，而当拥有一个原型对象时，则可以直接克隆一个对象，避免繁杂的操作。

# 结构型

这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

结构型的模式有以下几种：

- 适配器模式（Adapter Pattern）
- 桥接模式（Bridge Pattern）
- 过滤器模式（Filter、Criteria Pattern）
- 组合模式（Composite Pattern）
- 装饰器模式（Decorator Pattern）
- 外观模式（Facade Pattern）
- 享元模式（Flyweight Pattern）
- 代理模式（Proxy Pattern）

## 适配器模式

适配器模式（Adapter Pattern）是**作为两个不兼容的接口之间的桥梁**。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

**这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。**举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。

**意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

**何时使用：** 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

**如何解决：**继承或 **依赖（推荐）**。

**关键代码：**适配器继承或依赖已有的对象，实现想要的目标接口。

**应用实例：** 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。

**优点：** 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

**缺点：** 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

**使用场景：**有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

**注意事项：**适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

### 实现

```java
public class AdapterTest {
    public static void main(String[] args) {
        AdapterTest client = new AdapterTest();
        // 创建一个飞虎
        Adapter adapter = new Adapter(new Tiger(), new BigBird());
        client.call(adapter);
    }
    
    public void call(Adapter adapter) {
        adapter.fly();
        adapter.run();
    }
}

// 陆生动物会跑
interface Ground {
    public void run();
}

// 老虎实体类
class Tiger implements Ground {
    public void run() {
        System.out.println("tiger run");
    }
}

// 飞禽会飞
interface Sky {
    public void fly();
}

// 小鸟实体类
class BigBird implements Sky {
    public void fly() {
        System.out.println("bird fly");
    }
}

// 将一个飞禽和一个陆生动物“合体” （继承的方式）
class Adapter implements Sky, Ground {
    private Ground ground;
    private Sky sky;

    public Adapter(Ground g, Sky s) {
        this.ground = g;
        this.sky = s;
    }

    public void run() {
        ground.run();
    }

    public void fly() {
        sky.fly();
    }
}

	// 依赖的方式
//class FlyTigerAdapter implements Sky {
//    Ground ground;
//    
//    public FlyTigerAdapter(Ground ground) {
//        this.ground = ground;
//    }
//
//    @Override
//    public void fly() { 
//        ground.run();
//        System.out.println("also can fly");
//    }
//}
```

上面代码的适配器是通过实现两个接口进行适配，是通过继承的方式实现的。但是推荐使用依赖的方式实现。

**JDK中的适配器模式**：

- [java.util.Arrays#asList()](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList(T...))
- [java.util.Collections#list()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-)
- [java.util.Collections#enumeration()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-)
- [javax.xml.bind.annotation.adapters.XMLAdapter](http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-)

### 理解

​	适配器模式是属于结构型模式，不同于创建模式，是用于改变结构的模式。该模式通过连接两个独立的接口，将接口A适配接口B（通过类的复用改变了两个接口的结构，但是两个接口是不被影响的），且对调用者透明（对调用者透明有好有坏，当调用接口A时，却被是适配成了接口B的实现，这是需要通过更多的逻辑判断调用者到底是需要调用哪个接口）。

​	其实适配器模式的主要目的是通过”拼接“两个接口，实现一个拥有两个接口功能的新”种类“。

## 桥接模式

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。

**意图：**将抽象部分与实现部分分离，使它们都可以独立的变化。

**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

**何时使用：**实现系统可能有多个角度分类，每一种角度都可能变化。

**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

**关键代码：**抽象类依赖实现类。

**应用实例：** 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。

**优点：** 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。

**缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

**使用场景：** 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

**注意事项：**对于两个独立变化的维度，使用桥接模式再适合不过了。

### 实现

```java
public class BridgeDemo {
    public static void main(String[] args) {
        // 书的类型
        Book novel = new Novel();
        Book comic = new Comic();
        
        // 染料
        Color red = new Red();
        Color blue = new Blue();
        
        // 自由选择任意组合
        novel.setColor(red);
        novel.read();
        
        novel.setColor(blue);
        novel.read();
        
        comic.setColor(blue);
        comic.read();
    }
}

abstract class Book {
    Color color;

    public void setColor(Color color) {
        this.color = color;
    }

    public abstract void read();
}

interface Color {
    public void paint(String book);
}

class Novel extends Book {

    @Override
    public void read() {
        color.paint("Novel");
    }
}

class Comic extends Book {

    @Override
    public void read() {
        color.paint("comic book");
    }
}

class Red implements Color {

    @Override
    public void paint(String book) {
        System.out.println("Red " + book);
    }
}

class Blue implements Color {

    @Override
    public void paint(String book) {
        System.out.println("Blue " + book);
    }
}
```

**JDK中的桥接模式：**

- AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)
- JDBC

### 理解

​	桥接模式是用于把实现化与抽象化解耦，使得两者可以独立变化。该模式通过“桥接”将高耦合的继承关系独立开来，改变原本的继承结构，变成抽象依赖接口或抽象（聚合）的结构，使得抽象化层（前面语句的前者）可以新增功能（变化）而不影响实现化层（前面语句的后者），反之亦然。

​	举个上面实现代码的例子，我们将Color接口从代码中抹去，Book类不依赖Color，而是在Book类上新增颜色的功能。此时Book抽象类的变化必然会引起其实现类的变化，这就是继承关系（高度耦合）导致的结果。

​	说白了，桥接模式就是将继承换成了聚合。

## 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。

在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

**意图：**为其他对象提供一种代理以控制对这个对象的访问。

**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

**何时使用：**想在访问一个类时做一些控制。

**如何解决：**增加中间层。

**关键代码：**实现与被代理类组合。

**应用实例：** 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。

**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。

**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

**使用场景：**按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。

**注意事项：** 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

**代理有以下四类：**

- 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。
- 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。
- 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。
- 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。

### 实现

```java
public class ProxyDemo {
    public static void main(String[] args) {
        Image image = new ProxyImage("test.jpg");
        System.out.println("第一次display（需要创建源对象）：");
        image.display();
        
        System.out.println("第二次display（使用代理类，不需要从磁盘加载）：");
        image.display();
    }
}

interface Image {
    public void display();
}

class RealImage implements Image {
    
    private String fileName;

    public RealImage(String fileName) {
        this.fileName = fileName;
        loadFromDisk(fileName);
    }

    @Override
    public void display() {
        System.out.println("display " + fileName);
    }
    
    private void loadFromDisk(String fileName) {
        System.out.println("loading " + fileName);
    }
}

class ProxyImage implements Image {
    private String fileName;
    private RealImage realImage;
    
    public ProxyImage(String fileName) {
        this.fileName = fileName;
    }

    @Override
    public void display() {
        if (realImage == null)
            realImage = new RealImage(fileName);
        realImage.display();
    }
}
```

**JDK中的代理模式：**

- java.lang.reflect.Proxy
- RMI

### 理解

​	代理模式，顾名思义，就是创建一个代理类，改变客户访问真正对象的方式。从生活角度看代理模式，就像是百姓需要见皇帝，为了避免百姓刺杀皇帝，通常需要一个代理去检验百姓是否安全（保护代理）。如果皇帝愿意接见百姓，但是因为距离问题，百姓无法在短时间内访问皇帝，就需要在百姓所在的城镇上有一个皇帝代理负责该百姓的访问（远程代理）。

​	从上面代码实现来看，类似与单例模式的实现，不过单例模式是注重“创建”，代理模式注重“结构”。

## 组合模式

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。

**意图：**将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

**主要解决：**它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

**何时使用：** 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

**如何解决：**树枝和叶子实现统一接口，树枝内部组合该接口。

**关键代码：**树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

**应用实例：** 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。

**优点：** 1、高层模块调用简单。 2、节点自由增加。

**缺点：**在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

**使用场景：**部分、整体场景，如树形菜单，文件、文件夹的管理。

**注意事项：**定义时为具体类。

### 实现

```java
public class CompositeDemo {

    public static void main(String[] args) {
        BaseballTeam yankees = new BaseballTeam();
        yankees.add(new BaseballMember("Gerrit Cole", "P"));
        yankees.add(new BaseballMember("Aaron Judge", "RF"));
        yankees.add(new BaseballMember("Luke Voit", "1B"));
        yankees.add(new BaseballMember("DJ LeMahieu", "2B"));
        for (BaseballMember member : yankees.list()) {
            System.out.println("name:" + member.getName() + ", dube:" + member.getDube());
        }
    }

}

class BaseballTeam {
    private List<BaseballMember> members;

    public BaseballTeam() {
        this.members = new ArrayList<>();
    }
    
    public List<BaseballMember> list(){
        return members;
    }
    
    public void add(BaseballMember baseballMember) {
        members.add(baseballMember);
    }

    public boolean remove(BaseballMember baseballMember) {
        if (members.contains(baseballMember)) {
            members.remove(baseballMember);
            return true;
        } else {
            return false;
        }
    }
}

class BaseballMember {
    private String name;

    private String dube;

    public BaseballMember(String name, String dube) {
        this.name = name;
        this.dube = dube;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDube() {
        return dube;
    }

    public void setDube(String dube) {
        this.dube = dube;
    }
}

//class BaseballMember {
//    private List<BaseballMember> members;
//    
//    private String name;
//
//    private String dube;
//    
//    
//
//    public BaseballMember() {
//        members = new ArrayList<>();
//    }
//
//    public BaseballMember(String name, String dube) {
//        this.name = name;
//        this.dube = dube;
//    }
//    
//    public List<BaseballMember> list(){
//        return members;
//    }
//    
//    public void add(BaseballMember baseballMember) {
//        members.add(baseballMember);
//    }
//
//    public boolean remove(BaseballMember baseballMember) {
//        if (members.contains(baseballMember)) {
//            members.remove(baseballMember);
//            return true;
//        } else {
//            return false;
//        }
//    }
//
//    @Override
//    public String toString() {
//        return "BaseballMember :[name=" + name + ", dube=" + dube + "]";
//    }
//}
```

根据OCP，可以再定义一个Team的抽象类，实现可扩展。

**JDK中的组合模式：**

- javax.swing.JComponent#add(Component)
- java.awt.Container#add(Component)
- java.util.Map#putAll(Map)
- java.util.List#addAll(Collection)
- java.util.Set#addAll(Collection)

### 理解

​	组合模式的重点在于树形结构。使用树来表示整体和部分，在一个对象（父节点）中包含其他对象（子节点），这些其他对象可以是终点对象（不再包含其他对象），也可以是非终点对象（内部还含有其他对象），由此可知父对象内部就会形成一个树性关系。

# 行为型

这些设计模式特别关注对象之间的通信。

行为型的模式有以下几种：

- 责任链模式（Chain of Responsibility Pattern）
- 命令模式（Command Pattern）
- 解释器模式（Interpreter Pattern）
- 迭代器模式（Iterator Pattern）
- 中介者模式（Mediator Pattern）
- 备忘录模式（Memento Pattern）
- 观察者模式（Observer Pattern）
- 状态模式（State Pattern）
- 空对象模式（Null Object Pattern）
- 策略模式（Strategy Pattern）
- 模板模式（Template Pattern）
- 访问者模式（Visitor Pattern）

## 观察者模式

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

**意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**主要解决：**一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

**何时使用：**一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

**如何解决：**使用面向对象技术，可以将这种依赖关系弱化。

**关键代码：**在抽象类里有一个 ArrayList 存放观察者们。

**应用实例：** 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。

**优点：** 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。

**缺点：** 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

**使用场景：**

1. 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
2. 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
3. 一个对象必须通知其他对象，而并不知道这些对象是谁。
4. 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

**注意事项：** 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。

### 实现

```java
public class ObserversDemo {
    public static void main(String[] args) {
        BeObserver beObserver = new BeObserver();
        new BinaryObserver(beObserver);
        new OctalObserver(beObserver);
        
        System.out.println("first state change: 15");
        beObserver.setState(15);
        
        System.out.println("second state change: 10");
        beObserver.setState(10);
    }
}

// 被观察者是被成定义接口还是类，看具体需求
class BeObserver {
    List<Observer> observers = new ArrayList<>();
    private int state;

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
        notifyAllObservers();
    }

    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    // 是否添加删除观察者的方法（取消订阅），看具体需求

    public void notifyAllObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}

abstract class Observer {
    protected BeObserver beObserver; // 这里可以不依赖被观察者，可以只定义需要关注的状态（变量）

    public abstract void update();
}

class BinaryObserver extends Observer {

    public BinaryObserver(BeObserver beObserver) {
        this.beObserver = beObserver;
        this.beObserver.attach(this);
    } 
    
    @Override
    public void update() {
        System.out.println("Binary String: " + Integer.toBinaryString(beObserver.getState()));
    }
}

class OctalObserver extends Observer {
    
    public OctalObserver(BeObserver beObserver) {
        this.beObserver = beObserver;
        this.beObserver.attach(this);
    } 

    @Override
    public void update() {
        System.out.println("Octal String: " + Integer.toOctalString(beObserver.getState()));
    }
}
```

**JDK中的观察者模式：**

- [java.util.Observer](http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html)
- [java.util.EventListener](http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html)
- [javax.servlet.http.HttpSessionBindingListener](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html)
- [RxJava](https://github.com/ReactiveX/RxJava)

### 理解

​	观察者模式重点在于观察对象的状态，对象的行为导致对象的状态发生改变后，需要告知观察者。由此可见，观察者模式与“关注订阅”十分相似（redis的发布订阅）。

# J2EE模式

这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。

J2EE 模式有以下几种：

- MVC 模式（MVC Pattern）
- 业务代表模式（Business Delegate Pattern）
- 组合实体模式（Composite Entity Pattern）
- 数据访问对象模式（Data Access Object Pattern）
- 前端控制器模式（Front Controller Pattern）
- 拦截过滤器模式（Intercepting Filter Pattern）
- 服务定位器模式（Service Locator Pattern）
- 传输对象模式（Transfer Object Pattern）

# 设计模式之间的关系

下面用一个图片来整体描述一下设计模式之间的关系：

![设计模式之间的关系](https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg)

# 参考资料

[菜鸟教程]: https://www.runoob.com/design-pattern/design-pattern-intro.html

