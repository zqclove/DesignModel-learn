# 设计模式

# 设计模式的六大原则

## **1、开闭原则（Open Close Principle）**

开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，**是为了使程序的扩展性好，易于维护和升级。**想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

## **2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP  是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

## **3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。（依赖降级）

## **4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

## **5、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

## **6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

**笔记：**

在面向对象设计模式中存在的是五大原则和一个法则。

**五大原则:**

- 单一职责 SRP(Single Responsibilities Principle)
- 开闭原则 OCP(Open Close Principle)
- 里氏代换 LSP(Liskov Substitution Principle)
- 倒转依赖 DIP(Dependence Inversion Principle)
- 接口隔离 ISP(Interface Segregation Principle)

一个法则是：迪米特 DP (Demeter Principle)

​	迪米特法则是管理中涉及的一个术语，被引用到面向对象术语体系中，又称知识最少原则。Least Knowledge  Principle正儿八经的翻译是就是知识最少原则，不知道哪个英文水平不济的把knowledge翻译成了知道，汉语中知道是动词没有名词的意思，而knowledge译成见闻也比相对好一点。虽然现在都知道“知道”的意思。另外，在一些台系的书中迪米特法则也被翻译成“德默特尔法则”，当你看到这个时不要奇怪——音译本就会出现多个译法的。

​	其实在清华出版社中软件设计师书中，迪米特虽然被称为法则，但其与其他五大原则是同样的重要的，所以有些人会混称为面向对象六大原则，事实上在软件设计师考试中经常使用的面向对象五大原则。按清华出版社软件设计师体系来说，面向对象五大原则和一个法则（迪法特法则）。其他时候程序员也称为六大原则。

​	在MSDN类库设计原则中提到“尽量少使用继承，而使用组合与聚合“，但其并没有说明原因。微软的惯例就是如此，只告诉你应该如何，不应该如何，尽量如何或尽量不如何，从来不会告诉你原则。在面向对象设计中（清华出版社软件设计师一书中）讲到**五大原则与法则共同的目标就是高内聚低耦合的代码。**

​	其中高内聚指的是类内成员之间的关系，而低耦合则是类关系。要求就是类内各成员的关系尽量高，并按照一定的方式对内聚性进行排序。而讲到耦合关系，按照一定的方式也进行了排序；也就是内聚度与耦合度对这种关系进行了一定程度上量化。所以此处提到了继承——继承是耦合度最高的一种关系。所以提示了一句话是**尽量使用组合或聚合的方式来代替继承，或者使用最简单的继承树关系，当然也提示了继承应该继承于抽象类，避免继承实现类。**这个是对高内聚低耦合的一个补充说明，而且没有绝对的定义。所以并不是几大原则之中的事。而且有前提前条件，只是避免继承普通类！所以合成复用原则完全是某个人背完了原则忘记了而瞎编出来的（只是会背不会用或不理解，当然容易忘记了）！

​	当然，**单一职责原则其实就是为了提高内聚性一个说明，它的目的就保证了内聚性，只有一个引起变化的原因，说明类内成员之间的关系较高，内聚性不强的就不要写到一个类中。**这就是单一职责的真正用意。事实上很多程序员爱写大类超多成员或爱用静态成员，都是对内聚性的一种破坏——所以这些人很难想起来还有一个单一职责的原则！慢慢的这个原则就是被忘记了！

***以上来自 tech_monkey的笔记***

# 设计模式之间的关系

下面用一个图片来整体描述一下设计模式之间的关系：

![设计模式之间的关系](https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg)

# 参考资料

[菜鸟教程]: https://www.runoob.com/design-pattern/design-pattern-intro.html

